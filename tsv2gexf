#!/usr/bin/env python

import argparse
import os
import re

import pandas as pd

import cypher_queries as Cypher
import database
from gexf import GEXF
from KEGG.api import map_identifiers_to_STRING

NEO4J_GRAPH = database.connect_neo4j()

def parse_cli_args():

    parser = argparse.ArgumentParser()

    parser.add_argument(
        "tsv_path",
        type=str
    )

    parser.add_argument(
        "--clusters",
        nargs="+",
        type=int
    )

    args = parser.parse_args()

    return args

def filter_clusters(df, clusters):
    mask = False
    for idx in clusters:
        mask = mask | (df.gene_cluster == f"cluster {idx}")
    return df[mask]

def calculate_timesteps(df):
    # Column names
    col_names = df.columns.values.tolist()

    # Find the time columns
    pattern = re.compile(r"wt(\d+)h_wt(\d+)h")

    # Column-to-timestep map
    col2timestep = dict()
    for col_name in col_names:
        match = pattern.match(col_name)
        if not match:
            continue

        referent = int(match.group(2))
        relative = int(match.group(1))
        col2timestep[col_name] = referent + relative

    return col2timestep

def build_dynamic_graph(df, gexf_path):
    # Calculate timesteps
    col2timestep = calculate_timesteps(df)
    t_min = min(col2timestep.values())
    t_max = max(col2timestep.values())

    # Map gene IDs to protein IDs via STRING API
    from io import StringIO
    external_gene_ids = df.ENSEMBL.tolist()
    external_protein_ids = None
    for tsv, _ in map_identifiers_to_STRING(external_gene_ids):
        ids = pd.read_csv(StringIO(tsv), sep="\t").stringId
        if external_protein_ids is None:
            external_protein_ids = ids
        else:
            external_protein_ids = pd.concat([external_protein_ids, ids])

    external_protein_ids = external_protein_ids.tolist()
    assert len(external_gene_ids) == len(external_protein_ids)

    protein2gene = dict()
    for gene_id, protein_id in zip(external_gene_ids, external_protein_ids):
        protein2gene[protein_id] = gene_id

    # Get data from Neo4j
    subgraph = Cypher.get_proteins_subgraph(NEO4J_GRAPH, external_protein_ids, threshold=0.7, external=True)
    data = list(subgraph)
    assert data, "Neo4j didn't return anthing!"
    data = data[0]

    # Graph
    with GEXF(gexf_path) as gexf:
        # Nodes
        gexf.set_node_attributes(
            GEXF.Attribute("description", type=str),
            GEXF.Attribute("DE", type=float, default=0.)
        )

        internal2external = dict()
        for protein in data["proteins"]:
            gene_id = protein2gene[protein["external_id"]]
            row = df[df.ENSEMBL == gene_id].iloc[0]

            internal2external[protein["id"]] = protein["external_id"]

            attrvals = [GEXF.AttributeValue("description", protein["description"])]
            prev_timestep = 0
            for col, timestep in sorted(col2timestep.items(), key=lambda t: t[1]):
                value = row[col]
                attrval = GEXF.AttributeValue("DE", value, prev_timestep, timestep)
                attrvals.append(attrval)
                prev_timestep = timestep

            gexf.add_node(GEXF.Node(row.ENSEMBL, row.SYMBOL, start=t_min, end=t_max, attrvals=attrvals))

        # Edges
        gexf.set_edge_attributes(
            GEXF.Attribute("combined_score", type=float, default=0.)
        )
        for association in data["associations"]:
            gene1_id = protein2gene[internal2external[association["protein1_id"]]]
            gene2_id = protein2gene[internal2external[association["protein2_id"]]]
            gexf.add_edge(GEXF.Edge(gene1_id, gene2_id, start=t_min, end=t_max, attrvals=[
                GEXF.AttributeValue("combined_score", association["combined_score"])
            ]))

def main():
    # Parse the arguments
    args = parse_cli_args()

    # Make sure the file exists
    if not os.path.exists(args.tsv_path):
        print("The specified TSV file does not exist!")
        return

    # Read the TSV file
    df = pd.read_csv(args.tsv_path, sep="\t")

    # Remove rows containing NaN values
    df = df.dropna()

    # Filter the clusters
    if args.clusters is not None:
        df = filter_clusters(df, args.clusters)

    # Build a dynamic graph
    root, ext = os.path.splitext(args.tsv_path)
    gexf_path = f"{root}.gexf"
    build_dynamic_graph(df, gexf_path)

if __name__ == "__main__":
    main()
