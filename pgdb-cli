#!/usr/bin/env python

"""
CLI script for the Neo4j graph database.
"""

import readline
from pathlib import Path
import argparse
import datetime
import time

import pandas as pd
import py2neo

import database
from utils import exit_on

# ===================================== CLI arguments =====================================

def parse_cli_args():
    """
    Parses the command line arguments.
    """

    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-i",
        action="store_true",
        dest="interactive",
        help="Run the CLI in the interactive mode"
    )

    parser.add_argument(
        "--name",
        type=str,
        help="Name under which the batch results will be saved"
    )

    return parser.parse_args()

# ===================================== Input =====================================

def read_until_eof(interactive=True):
    """
    Reads lines from the standard input until the end-of-file (EOF).

    Returns:
    - lines that were read (list)
    """

    lines = list()

    @exit_on(EOFError)
    def read_line():
        line = input((". " if lines else "> ") if interactive else "").strip()
        return line

    while True:
        line = read_line()
        if line is None:
            print()
            break
        lines.append(line)

    return "\n".join(lines)

def read_until_empty_line():
    """
    Reads lines from the standard input until the newline (\n) or the end-of-file (EOF).
    Returns a tuple consisting of:

    - lines that were read (list)
    - flag indicating whether EOF was encountered (bool)
    """

    lines = list()

    @exit_on(EOFError)
    def read_line():
        line = input().strip()
        return line

    while True:
        line = read_line()
        if not line:
            break
        lines.append(line)

    should_exit = line is None
    return "\n".join(lines), should_exit


# ===================================== Handlers =====================================
_HANDLERS = []

def resolve_handler(cursor):
    """
    Accepts a Neo4j cursor and returns a tuple consisting of:
    - `handle` (function)
    - `args` (tuple of arguments for `handle`)
    """

    columns = cursor.keys()

    for predicate, handle in _HANDLERS:
        if predicate(columns):
            args = (cursor,)
            if handle is handle_rest or handle is handle_drugs_compounds_diseases:
                args += (columns,)
            break

    return handle, args

# Protein-protein interaction

def handle_protein_interactions(cursor):
    """
    Handler for protein - protein interaction data.

    Returns a dict with two pandas.DataFrames:
    - nodes
    - edges
    """

    nodes = pd.DataFrame(columns=["id", "external_id", "name", "description", "species_id"])
    edges = pd.DataFrame(columns=["source", "target", "score"])

    for row in cursor:
        source = row["source"]
        target = row["target"]
        score = row["score"]
        nodes.loc[source["id"]] = source
        nodes.loc[target["id"]] = target
        edges.loc[f"{source['id']}{target['id']}"] = {
            "source": source["id"],
            "target": target["id"],
            "score": score
        }

    return {
        "nodes": nodes,
        "edges": edges
    }

_HANDLERS.append((
    lambda columns: "source" in columns and "target" in columns and "score" in columns,
    handle_protein_interactions
))

# Protein list

def handle_proteins(cursor):
    """
    Handler for a list of proteins.

    Returns a dict with one pandas.DataFrame:
    - nodes
    """

    nodes = pd.DataFrame(columns=["id", "external_id", "name", "description", "species_id"])

    for row in cursor:
        protein = row["protein"]
        nodes.loc[protein["id"]] = protein

    return {
        "nodes": nodes
    }

_HANDLERS.append((
    lambda columns: "protein" in columns,
    handle_proteins
))

# Pathway list

def handle_pathways(cursor):
    """
    Handler for a list of pathways.

    Returns a dict with one pandas.DataFrame:
    - nodes
    """

    nodes = pd.DataFrame(columns=["id", "name", "description", "species_id"])

    for row in cursor:
        pathway = row["pathway"]
        nodes.loc[pathway["id"]] = pathway

    return {
        "nodes": nodes
    }

_HANDLERS.append((
    lambda columns: "pathway" in columns,
    handle_pathways
))

# Drugs, compound and disease lists

def handle_drugs_compounds_diseases(cursor, columns):
    """
    Handler for a list of drugs, compounds and diseases.

    Returns a dict with at least one of the following pandas.DataFrames:
    - drugs
    - compounds
    - diseases
    """

    drugs = pd.DataFrame(columns=["id", "name"])
    compounds = pd.DataFrame(columns=["id", "name"])
    diseases = pd.DataFrame(columns=["id", "name"])

    for row in cursor:
        if "drug" in columns:
            drug = row["drug"]
            drugs.loc[drug["id"]] = drug
        if "compound" in columns:
            compound = row["compound"]
            compounds.loc[compound["id"]] = compound
        if "disease" in columns:
            disease = row["disease"]
            diseases.loc[disease["id"]] = disease

    dataframes = dict()
    if drugs.index.tolist():
        dataframes["drugs"] = drugs
    if compounds.index.tolist():
        dataframes["compounds"] = compounds
    if diseases.index.tolist():
        dataframes["diseases"] = diseases

    return dataframes

_HANDLERS.append((
    lambda columns: "drug" in columns or "compound" in columns or "disease" in columns,
    handle_drugs_compounds_diseases
))

# Rest of the data

def handle_rest(cursor, columns):
    """
    Handler for the rest of the data.

    Returns a dict with all the data put into a single pandas.DataFrame:
    - nodes
    """

    dataframe = pd.DataFrame(columns=columns)

    for idx, row in enumerate(cursor):
        dataframe.loc[idx] = row

    return {
        "table": dataframe
    }

_HANDLERS.append((
    lambda columns: True,
    handle_rest
))

# ===================================== Helpers =====================================

@exit_on(py2neo.status.ClientError, print_msg=True)
def run_query(neo4j_graph, query):
    """
    Runs a Cypher query to a Neo4j database and returns
    a cursor.
    """

    cursor = neo4j_graph.run(query)
    return cursor

@exit_on(KeyboardInterrupt)
def save():
    """
    Prompts the user whether he / she wants to save.
    Answering `y` returns True and `n` returns false.
    """

    while True:
        option = input("Save (y/n)? ").lower().strip()
        if option == "y":
            return True
        if option == "n":
            return False

@exit_on(Exception, print_msg=True)
@exit_on(KeyboardInterrupt)
def get_path():
    """
    Prompts the user to type in a path to a file.
    All non-existing directories are created.
    """

    path_raw = input("Path: ")
    Path(path_raw).parent.mkdir(parents=True, exist_ok=True)
    return path_raw

def get_batch_id():
    """
    Generates an ID for the batch mode.
    """

    now = datetime.datetime.now()
    return f"{now.year}-{now.month}-{now.day}-{now.hour}-{now.minute}-{now.second}"

# ===================================== Loops =====================================

_HEAD_N = 5

@exit_on(KeyboardInterrupt)
def interactive_loop(neo4j_graph, args):
    """
    Main loop for the interactive mode.
    """

    while True:
        query = read_until_eof()
        if not query:
            continue

        cursor = run_query(neo4j_graph, query)
        if not cursor:
            continue

        handle, args = resolve_handler(cursor)

        dataframes = handle(*args)
        for name, df in dataframes.items():
            print(f"[{name}]")
            print(df.head(n=_HEAD_N))
            if len(df) > _HEAD_N:
                print("...")

            if save():
                path = get_path()
                if path is None:
                    print()
                    continue
                df.to_csv(path, index=False)

@exit_on(KeyboardInterrupt)
def batch_loop(neo4j_graph, args):
    """
    Main loop for the batch mode.
    """

    idx = 1
    should_exit = False
    batch_id = get_batch_id() if args.name is None else args.name
    directory = Path(".", batch_id)

    start_time = time.time()
    failed = 0
    while not should_exit:
        query, should_exit = read_until_empty_line()
        if not query:
            continue

        print(f"Query {idx}")

        cursor = run_query(neo4j_graph, query)
        if not cursor:
            idx += 1
            failed += 1
            continue

        handle, args = resolve_handler(cursor)

        dataframes = handle(*args)
        directory.mkdir(parents=True, exist_ok=True)
        for name, df in dataframes.items():
            path = directory / Path(f"{idx:04d}.{name}.csv")
            df.to_csv(str(path), index=False)

        idx += 1

    end_time = time.time()
    total = idx - 1
    successful = total - failed

    print()
    print(f"Data written to {directory.resolve()}")
    print(f"Time elapsed: {end_time - start_time:.2f} s")
    print(f"{total} queries: {successful} successful, {failed} failed")

# ===================================== Main =====================================

def main():
    """
    Main procedure.
    """

    args = parse_cli_args()

    neo4j_graph = database.connect_neo4j()

    print("=== Protein Graph Database CLI ===")

    if args.interactive:
        interactive_loop(neo4j_graph, args)
    else:
        batch_loop(neo4j_graph, args)

if __name__ == "__main__":
    main()
