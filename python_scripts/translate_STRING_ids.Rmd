---
title: "Home"
author: "Dilmurat Yusuf"
output:
    html_document:
        toc: true
        toc_float: true
        toc_depth: 4
        df_print: paged
---
**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r packages, results='hide', message=FALSE, warning=FALSE}
library(dplyr)
library(data.table)
library(biomaRt)
library(httr)
```
# read the table of protein info from string-db
protein_url = "https://stringdb-static.org/download/protein.info.v11.5/10090.protein.info.v11.5.txt.gz"
string_proteins <- data.table::fread(protein_url)

#--- copy the available ENSEMBL gene ids in STRING table. no translation needed
# in the column -- preferred_name -- gene symbols used for most cases
# in a case of 1.28%, ENSEMBL gene IDS used instead of gene symbols
# for this fraction, no need to make translation to ENSEMBL IDs
# extract preferred_name using ENSEMBL ids
prefer_enseml <- subset(string_proteins, grepl("ENSMUSG", string_proteins$preferred_name))$preferred_name
# copy the available ENSEMBL IDs to the new column
string_proteins$ENSEMBL = 'NA'
for (symbol in prefer_enseml){
  string_proteins[preferred_name==symbol, ENSEMBL := symbol]
}
string_proteins %>% str
#---
#--- convert symbols to ENSEMBL IDs
# get the symbols with no correponding ENSEMBL IDs converted
string_symbols <- subset(string_proteins, ENSEMBL == 'NA') %>%
               .$preferred_name

# I diecide to use ENSEMBL api to make convertion
# The reason: accurate and updated
# The drawback: slow
# Since it is a one-time execution, the lacking of efficiency is not a major issue
# Define the API endpoint and parameters
headers <-  add_headers("Content-Type" = "application/json")
# fectch ENSEMBL id of symbols with duplicated ENSEMBL via ensembldb
# query them via ENSEMBL api
string_symb_ens <- data.table(SYMBOL = c(), ENSEMBL = c())
for (symbol in string_symbols){
  url <- "http://rest.ensembl.org/xrefs/symbol/mouse/"
  endpoint <- paste0(url, symbol)
  response <- GET(endpoint, headers)
  stop_for_status(response)
  data <- content(response)

  if (! length(data) == 0){
    # for some cases, there are multiple hits
    for (item in data){
      new_row = data.table(SYMBOL = symbol,  ENSEMBL = item$id)
      string_symb_ens <- rbind(string_symb_ens, new_row)
    }
  }
}
# there are 234 symbols not convered to ENSEMBL IDs
setdiff(string_symbols, string_symb_ens$SYMBOL) %>% length

write.table(string_symb_ens, "string_symb_ens.tsv", sep = "\t", row.names = FALSE, quote = FALSE)
#---
#--- remove the mistmached ENSEMBL IDs of a symbol
# find dubious ENSEMBL IDs for some symbols
# they are usually in the duplicated ENSEMBL
string_symb_ens <- fread("string_symb_ens.tsv", sep = "\t", header = TRUE)
dubious_symbol <- string_symb_ens[duplicated(SYMBOL)]$SYMBOL
# get all duplicated ENSEMBL IDS
dubious_ens <- string_symb_ens[SYMBOL %in% dubious_symbol]

# match ENSEMBL ID and correponding symbol
# need to function to get aliases of symbols
# sometimes symbols used in STRING are the aliases of symbols in ENSEMBL
get_alias <- function(symbol){
  # Connect to the Ensembl database for mouse
  server <- "https://rest.ensembl.org"
  ext <- paste0("/xrefs/name/mus_musculus/", symbol, "?")  # symbol = 'Slc23a1'

  response <- GET(paste(server, ext, sep = ""), content_type("application/json"))
  stop_for_status(response)

  aliases <- lapply(content(response), function(x) x$synonyms) %>% unlist
  return(aliases)
}

# use ENSEMBL api to verify the match between a ENSEMBL ID and symbol
# remove the dubious ones
for (i in 1:nrow(dubious_ens)){
  symbol = dubious_ens[i]$SYMBOL
  ensem = dubious_ens[i]$ENSEMBL

  # Define the Ensembl REST API endpoint
  endpoint <- paste0("https://rest.ensembl.org/lookup/id/", ensem, "?content-type=application/json")

  # Make the request to the Ensembl REST API
  response <- GET(endpoint)
  stop_for_status(response)

  # Extract the symbol from the response
  symbol_lookup <- content(response)$display_name # 'Lhx5' %in% string_proteins$preferred_name

  # sometimes lookup of ENSEMBL ID does not yield display_name
  # in this situation, set NULL as a string so it will work when
  # executing 'symbol == symbol_lookup' below
  if (is.null(symbol_lookup)){
    symbol_lookup = 'NULL'
  }

  # compare the correponding symbol of a ENSEMBL id with
  # its paried symbol in the table
  # they should match by either same name or alias
  # remove the unmatching ones
  if (! (symbol == symbol_lookup || symbol %in% get_alias(symbol_lookup))){
    string_symb_ens <- string_symb_ens[! (SYMBOL == symbol & ENSEMBL == ensem),]
  }
}

