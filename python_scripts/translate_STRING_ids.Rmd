---
title: "Home"
author: "Dilmurat Yusuf"
output:
    html_document:
        toc: true
        toc_float: true
        toc_depth: 4
        df_print: paged
---
**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r packages, results='hide', message=FALSE, warning=FALSE}
library(dplyr)
library(data.table)
library(biomaRt)
library(httr)
```

```{r buld_functions}
#' here to build serveral functions to communicate ENSEMBL apis

# convert symbol to ENSEMBL id
symbol_2_ensem <- function(symbol){
  url <- "http://rest.ensembl.org/xrefs/symbol/mouse/"
  endpoint <- paste0(url, symbol)
  response <- GET(endpoint, headers)
  stop_for_status(response)
  ensem <- content(response)

  return(ensem)
}

# when matching ENSEMBL ID and correponding symbol
# sometimes symbols used in STRING are the aliases of symbols in ENSEMBL
# need a function to get aliases of symbols
get_alias <- function(symbol){
  # Connect to the Ensembl database for mouse
  server <- "https://rest.ensembl.org"
  ext <- paste0("/xrefs/name/mus_musculus/", symbol, "?")

  response <- GET(paste(server, ext, sep = ""), content_type("application/json"))
  stop_for_status(response)

  aliases <- lapply(content(response), function(x) x$synonyms) %>% unlist
  return(aliases)
}

# convert ENSEMBL id to symbol
ensem_2_symbol <- function(ensem){
  # Define the Ensembl REST API endpoint
  endpoint <- paste0("https://rest.ensembl.org/lookup/id/", ensem, "?content-type=application/json")

  # Make the request to the Ensembl REST API
  response <- GET(endpoint)
  stop_for_status(response)

  # Extract the symbol from the response
  symbol <- content(response)$display_name

  return(symbol)
}
```

```{r translate_ids}
#' In this chunk,
#' IDs (protein ENSEMBL IDs or gene symbols) translated to ENSEMBL IDs

# read the table of protein info from string-db
protein_url = "https://stringdb-static.org/download/protein.info.v11.5/10090.protein.info.v11.5.txt.gz"
string_proteins <- data.table::fread(protein_url)

#--- copy the available ENSEMBL gene ids in STRING table. no translation needed
# in the column -- preferred_name -- gene symbols used for most cases
# in a case of 1.28%, ENSEMBL gene IDS used instead of gene symbols
# for this fraction, no need to make translation to ENSEMBL IDs
# extract preferred_name using ENSEMBL ids
prefer_enseml <- subset(string_proteins, grepl("ENSMUSG", string_proteins$preferred_name))$preferred_name
# copy the available ENSEMBL IDs to the new column
string_proteins$ENSEMBL = 'NA'
for (symbol in prefer_enseml){
  string_proteins[preferred_name==symbol, ENSEMBL := symbol]
}
string_proteins %>% str
#---

#--- convert symbols to ENSEMBL IDs
# get the symbols with no correponding ENSEMBL IDs converted
string_symbols <- subset(string_proteins, ENSEMBL == 'NA') %>%
               .$preferred_name

# I diecide to use ENSEMBL api to make convertion
# The reason: accurate and updated
# The drawback: slow
# Since it is a one-time execution, the lacking of efficiency is not a major issue
# Define the API endpoint and parameters
headers <-  add_headers("Content-Type" = "application/json")
# fectch ENSEMBL id of symbols with duplicated ENSEMBL via ensembldb
# query them via ENSEMBL api
string_symb_ens <- data.table(SYMBOL = c(), ENSEMBL = c())
for (symbol in string_symbols){
  ensem <- symbol_2_ensem(symbol) # symbol = 'Il10ra'
  if (! length(ensem) == 0){
    # for some cases, there are multiple hits
    for (item in ensem){
      new_row = data.table(SYMBOL = symbol,  ENSEMBL = item$id)
      string_symb_ens <- rbind(string_symb_ens, new_row)
    }
  }
}
# there are 234 symbols not convered to ENSEMBL IDs
setdiff(string_symbols, string_symb_ens$SYMBOL) %>% length

fwrite(string_symb_ens, "../data/string_symb_ens.tsv.gz", sep = "\t", row.names = FALSE, quote = FALSE, compress = "gzip")
#---

#--- remove the mistmached ENSEMBL IDs of a symbol
# find dubious ENSEMBL IDs for some symbols
# they are usually in the duplicated ENSEMBL
string_symb_ens <- fread("../data/string_symb_ens.tsv.gz", sep = "\t", header = TRUE)
dubious_symbol <- string_symb_ens[duplicated(SYMBOL)]$SYMBOL
# get all duplicated ENSEMBL IDS
dubious_ens <- string_symb_ens[SYMBOL %in% dubious_symbol]

# use ENSEMBL api to verify the match between a ENSEMBL ID and symbol
# remove the dubious ones
for (i in 1:nrow(dubious_ens)){
  symbol = dubious_ens[i]$SYMBOL
  ensem = dubious_ens[i]$ENSEMBL #test ensem='ENSMUSG00000032089'

  symbol_lookup <- ensem_2_symbol(ensem)
  # sometimes lookup of ENSEMBL ID does not yield display_name
  # in this situation, set NULL as a string so it will work when
  # executing 'symbol == symbol_lookup' below
  if (is.null(symbol_lookup)){
    symbol_lookup = 'NULL'
  }

  # compare the correponding symbol of a ENSEMBL id with
  # its paried symbol in the table
  # they should match by either same name or alias
  # remove the unmatching ones
  if (! (symbol == symbol_lookup || symbol %in% get_alias(symbol_lookup))){
    string_symb_ens <- string_symb_ens[! (SYMBOL == symbol & ENSEMBL == ensem),]
  }
}

# there are still duplicated ENSEMBL gene IDs for 264 symmbols
# 1) the case of a SYMBOL with multiple ENSEMBL gene IDs
# 2) the case of a alias symbols with the same ENSEMBL IDs
symbol_dupl_ensem <- string_symb_ens[duplicated(SYMBOL)]$SYMBOL
# add ENSEMBL IDs to the string table
string_symb_ens <- string_symb_ens[!duplicated(SYMBOL)]
for (symbol in string_symb_ens$SYMBOL){
  string_proteins[preferred_name==symbol, ENSEMBL := string_symb_ens[SYMBOL==symbol]$ENSEMBL]
}

# remove 283 preferred_name with ENSEMBL IDs
# even though these are to be included in the final table
# for the downstream analysis, such IDs should be removed
string_proteins_rm_prefer_ensem <- string_proteins[!preferred_name %in% prefer_enseml]

# correct duplicated ENSEMBLs caused by presence of aliases
dupl_ensem <- string_proteins_rm_prefer_ensem[duplicated(ENSEMBL) & ! ENSEMBL == 'NA']$ENSEMBL
dupl_ensem_symbol <- string_proteins_rm_prefer_ensem[ENSEMBL %in% dupl_ensem]
setorder(dupl_ensem_symbol, ENSEMBL)
# first seperate the ones with single ENSEMBL vs multi
single_ensem <- data.table(SYMBOL=c(), ENSEMBL=c())
multi_ensem <- data.table(SYMBOL=c(), ENSEMBL=c())
for (symbol in dupl_ensem_symbol$preferred_name){
  ensem <- symbol_2_ensem(symbol)

  if (! length(ensem) == 0){
    # for some cases, there are multiple hits
    for (item in ensem){
      new_row = data.table(SYMBOL = symbol,  ENSEMBL = item$id)
      if (length(ensem) == 1){
        single_ensem <- rbind(single_ensem, new_row)
      }
      else{
        multi_ensem <- rbind(multi_ensem, new_row)
      }
    }
  }
}

# remove the overlapping ENSEMBL IDs from multi_ensem
multi_ensem_filter <- multi_ensem[! ENSEMBL %in% single_ensem$ENSEMBL]
multi_ensem_dup <- multi_ensem_filter[duplicated(SYMBOL)]$SYMBOL %>% unique
multi_ensem_fixed <- multi_ensem_filter[! SYMBOL %in% multi_ensem_dup]

# use ENSEMBL api to verify the match between a ENSEMBL ID and symbol
# only inlcude the fixed match from ENSEMBL to symbol
multi_ensem_filter_dup <- multi_ensem_filter[SYMBOL %in% multi_ensem_dup]
multi_ensem_fixed_1 <- data.table(SYMBOL=c(), ENSEMBL=c())
for (i in 1:nrow(multi_ensem_filter_dup)){
  symbol = multi_ensem_filter_dup[i]$SYMBOL
  ensem = multi_ensem_filter_dup[i]$ENSEMBL

  symbol_lookup <- ensem_2_symbol(ensem)
  # sometimes lookup of ENSEMBL ID does not yield display_name
  # in this situation, set NULL as a string so it will work when
  # executing 'symbol == symbol_lookup' below
  if (is.null(symbol_lookup)){
    symbol_lookup = 'NULL'
  }

  # compare the correponding symbol of a ENSEMBL id with
  # its paried symbol in the table
  # they should match by either same name
  if (symbol == symbol_lookup){
    new_row <- data.table(SYMBOL = symbol,  ENSEMBL = ensem)
    multi_ensem_fixed_1 <- rbind(multi_ensem_fixed_1, new_row)
  }
}

multi_ensem_fixed <-  rbind(multi_ensem_fixed, multi_ensem_fixed_1)

# manually fixed the remaining ones
multi_ensem_filter[! SYMBOL %in% multi_ensem_fixed$SYMBOL]

manual_fixed = data.table(
  SYMBOL = c('Akap2', 'Palm2', 'Palm2Akap2', 'Gm3629', "BC037034"),
  ENSEMBL = c('ENSMUSG00000089945', 'ENSMUSG00000038729', 'ENSMUSG00000090053', 'NA', "NA")
)

multi_ensem_fixed <- rbind(multi_ensem_fixed, manual_fixed)
dupl_ensem_fixed <- rbind(single_ensem, multi_ensem_fixed)

# there are still duplicates of ENSEMBL IDs
# because of the presence of aliases with identical ENSEMBL IDs
alias_dup_ensem <- dupl_ensem_fixed[duplicated(ENSEMBL) & ENSEMBL != 'NA']$ENSEMBL
alias_dup_ensem_ <- dupl_ensem_fixed[ENSEMBL %in% alias_dup_ensem]
# with ENSEMBL api to map ENSEMBL ID to symbol
# set NA to thoese without the match
for (i in 1:nrow(alias_dup_ensem_)){
  symbol = alias_dup_ensem_[i]$SYMBOL
  ensem = alias_dup_ensem_[i]$ENSEMBL

  if (ensem=='NA'){
    next
  }

  symbol_lookup <- ensem_2_symbol(ensem)
  # sometimes lookup of ENSEMBL ID does not yield display_name
  # in this situation, set NULL as a string so it will work when
  # executing 'symbol == symbol_lookup' below
  if (is.null(symbol_lookup)){
    symbol_lookup = 'NULL'
  }

  # compare the correponding symbol of a ENSEMBL id with
  # its paried symbol in the table
  # they should match by same name
  if (! symbol == symbol_lookup){
    alias_dup_ensem_[SYMBOL==symbol, ENSEMBL := 'NA']
  }
}

# These lead to the loss of some ENSEMBL IDs
# reason: the alias SYMBOLs in STRING differ from the SYMBOLs in ENSEMBL
# so far I do not have a ideal solution (except manual curation) for this
dupl_ensem_fixed_2 <- dupl_ensem_fixed[! SYMBOL %in% alias_dup_ensem_$SYMBOL]
dupl_ensem_fixed_beta <- rbind(dupl_ensem_fixed_2, alias_dup_ensem_)

# add the fixed ENSEMBL to aviod duplicates
for (symbol in dupl_ensem_fixed_beta$SYMBOL){
  string_proteins[preferred_name==symbol, ENSEMBL := dupl_ensem_fixed_beta[SYMBOL==symbol]$ENSEMBL]
}

# after all these correction
# there are still ENSEMBL duplicates
# it turns out the corrected ENSEMBL overlapping with previously unique ones
dupl_ensem_final <- string_proteins[!grepl('ENS', preferred_name)][duplicated(ENSEMBL) & (!ENSEMBL=='NA')]$ENSEMBL
# fix it manually
manual_fixed_final = data.table(
  SYMBOL = c('Pcdhb17', 'Pan2'),
  ENSEMBL = c('ENSMUSG00000046387', 'ENSMUSG00000005682')
)
# set corrected ENSEMBL IDs in the final table
for (symbol in manual_fixed_final$SYMBOL){
  string_proteins[preferred_name==symbol, ENSEMBL := manual_fixed_final[SYMBOL==symbol]$ENSEMBL]
}

fwrite(string_proteins, "../data/string_SYMBOL_ENSEMBL.tsv,gz", sep = "\t", row.names = FALSE, quote = FALSE, na = 'NA', compress = "gzip")
#---
```

```{r verify_translation}
# make control of the quality of convertion between SYMBOL and ENSEMBL IDs
# call ENSEMBL api to match symbol of ENSEMBL query vs symbol in the table
string_SYMBOL_ENSEMBL <- fread("../data/string_SYMBOL_ENSEMBL.tsv.gz", sep = "\t", header = TRUE)
string_SYMBOL_ENSEMBL_ <- string_SYMBOL_ENSEMBL[!grepl('ENS', preferred_name)]
string_SYMBOL_ENSEMBL_ <- string_SYMBOL_ENSEMBL_[!is.na(ENSEMBL)]
unmatched <- data.table(SYMBOL=c(), ENSEMBL=c())
for (i in 1:nrow(string_SYMBOL_ENSEMBL_)){
  symbol = string_SYMBOL_ENSEMBL_[i]$preferred_name
  ensem = string_SYMBOL_ENSEMBL_[i]$ENSEMBL

  symbol_lookup <- ensem_2_symbol(ensem)
  # sometimes lookup of ENSEMBL ID does not yield display_name
  # in this situation, set NULL as a string so it will work when
  # executing 'symbol == symbol_lookup' below
  if (is.null(symbol_lookup)){
    symbol_lookup = 'NULL'
  }

  # compare the correponding symbol of a ENSEMBL id with
  # its paried symbol in the table
  # they should match by either same name
  if (! symbol == symbol_lookup){
    new_row <- data.table(SYMBOL = symbol, symbol_lookup=symbol_lookup,  ENSEMBL = ensem)
    unmatched <- rbind(unmatched, new_row)
  }
}

# 1000s symbols without match from the previuos step
# this is due to alias issue
# in this case query symbol for ENSEMBL
# match it against ENSEMBL in table
# the results is satisfactory, in the final table
# all paried SYMBOL and ENSEMBL IDs match
# for those with valid SYMBOLs in preferred_name column
# or valid ENSEMBL IDs in ENSEMBL column
unmatched_ <- unmatched
for (i in 1:nrow(unmatched_)){
  symbol = unmatched_[i]$SYMBOL # i = 1
  ensem = unmatched_[i]$ENSEMBL

  ensem <- symbol_2_ensem(symbol)
  if (! length(ensem) == 0){
    # for some cases, there are multiple hits
    ENSEMBL_lookup = c()
    for (item in ensem){
      ENSEMBL_lookup <- c(ENSEMBL_lookup, item$id)
    }
    if (ensem %in% ENSEMBL_lookup){
      unmatched <- unmatched[! SYMBOL==symbol]
    }
  }
}
```

```{r make_aliases}
# to create a table of aliases
# the aliases needed to registered in the graph database

string_SYMBOL_ENSEMBL <- fread("../data/string_SYMBOL_ENSEMBL.tsv.gz", sep = "\t", header = TRUE)
string_SYMBOL_ENSEMBL_ <- string_SYMBOL_ENSEMBL[!grepl('ENS', preferred_name)]
string_SYMBOL_ENSEMBL_ <- string_SYMBOL_ENSEMBL_[!is.na(ENSEMBL)]

# get aliases via ENSEMBL api
symbol_alias = data.table(SYMBOL=c(), aliases=c())
for (i in 1:nrow(string_SYMBOL_ENSEMBL_)){
  row = string_SYMBOL_ENSEMBL_[i] # i=1
  symbol = row$preferred_name # symbol = 'mt-Nd6'
  ensem = row$ENSEMBL # ensem = "ENSMUSG00000064368"
  aliases = get_alias(symbol) #

  # if no corresponding alias, set value to 'NA'
  if (is.null(aliases)){
    aliases = 'NA'
  }

  # sometimes, ENSEMBL ID appear in aliases
  # remove ENSEMBL ID from aliases
  if (ensem %in% aliases){
    aliases <- aliases[!aliases %in% ensem]
  }

  # join vector of aliases into a string
  aliases <- paste(aliases, collapse = ", ")

  new_row = data.table(SYMBOL=symbol, aliases=aliases)
  symbol_alias <- rbind(symbol_alias, new_row)
}

# add alias to the table of symbol ans ensemble gene ids
symbol_ensembl_alias <- merge(string_SYMBOL_ENSEMBL, symbol_alias, by.x='preferred_name', by.y='SYMBOL', all.x=TRUE)

fwrite(symbol_ensembl_alias, "../data/string_SYMBOL_ENSEMBL.tsv.gz", sep = "\t", row.names = FALSE, quote = FALSE, na = 'NA', compress = "gzip")
```
